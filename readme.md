这是一个用shell写的内网穿透工具

在说明文件里我还是以中文为主的。代码里注释也是用中文写。代码里的字符串常量之所以用英文写，是因为代码字符串里出现中文很容易出现编码不一致导致乱码的问题。我被坑过很多次，所以代码里非注释还是坚持全英文。

# 需要的工具

    1. nc
    2. ss
    3. dialog (可选)

# 使用说明

这里有4个概念：

    1. 用户 (也叫真正的用户)
    2. 服务端 (也叫真正的服务端)
    3. 虚假用户 (也叫虚拟用户、虚假客户端、虚拟客户端)
    4. 虚假服务端 (也叫虚拟服务端)

它们之间是以这种方式连接的：

    [用户] ----- [虚假服务端] ----- [虚假用户] ----- [服务端]
             1                 2               3

需要部署2个东西

    1. 虚假服务端
        这个东西需要部署到“能被用户访问到的地方”
    2. 虚假用户
        这个东西需要部署到“能够同时访问到虚假服务端和服务端的地方”
    
    对于单纯的内网穿透而言，虚假服务端部署到公网，虚假用户部署到和服务端同一个网络里（最简单的就是同一台机器里）即可。

这种方式需要对3个连接点进行设置：

    1. 用户 -- 虚假服务端
        这个连接点需要指定：
        1.1. 用户连接的端口 (real user port)
    2. 虚假服务端 -- 虚假用户
        这个连接点需要指定：
        2.1. 虚假服务端ip (virtual server ip)
        2.2. 虚假用户管理端口 (virtual server manager port 或 virtual user manager port)
        2.3. 虚假用户端口 (virtual server user port 或 virtual user port)
    3. 虚假用户 -- 服务端
        这个连接点需要指定：
        3.1. 服务端ip (real server ip)
        3.2. 服务端端口 (real server port)

## 1. 第一步 部署虚假服务端

需要指定：

    1. 用户连接的端口 (real user port)
        这个需要好好设置，要让用户知道这个端口
    2. 虚假用户管理端口 (virtual user manager port)
        这个随便乱设置一个端口即可，但要和虚假用户的“虚假服务端管理端口”口径一致
    3. 虚假用户端口 (virtual user port)
        这个随便乱设置一个端口即可，但要和虚假用户的“虚假服务端用户端口”口径一致

执行的文件是本目录下的`v_serv/v_serv`文件，这是一个shell脚本（实际上这个仓库除了这个readme.md其他全是shell脚本）。

需要设置3个参数，就是上面说的三个需要指定的东西。如果参数设置错误，会弹出dialog辅助调整。

## 2. 第二步 部署虚假用户

需要指定：

    1. 服务端ip (real server ip)
        这个可以填ip，也可以填域名
    2. 服务端端口 (real server port)
        这个就是真正的服务端实际上监听的端口
    3. 虚假服务端ip (virtual server ip)
        这个可以填ip，也可以填域名
    4. 虚假服务端管理端口 (virtual server manager port)
        要和虚假服务端的“虚假用户管理端口”口径一致
    5. 虚假服务端用户端口 (virtual server user port)
        要和虚假服务端的“虚假用户端口”口径一致

执行的文件是本目录下的`v_cli/v_cli`文件，这是一个shell脚本。

## 3. 一个例子

以下例子纯属瞎编，我怎么可能有域名为github.com的服务器。

比如我现在有一个服务，它是在内网里的，它的ip是192.168.1.2，监听端口是1234

假如我有一台有公网ip的服务器，它的域名是github.com

如果这个时候我想让全地球人访问我的内网192.168.1.2机器的1234端口的服务。那我可以这样做：

    在域名为github.com的机器里部署虚假服务端：
        我设置它的用户连接端口为：1234
        我设置它的虚假用户管理端口为：1111
        我设置它的虚假用户端口为：2222

        命令为 (在Linux终端执行)：
            v_serv/v_serv 1234 1111 2222
    
    在ip为192.168.1.2的机器里部署虚假用户：
        我设置它的服务端ip为：127.0.0.1
        我设置它的服务端端口为：1234
        我设置它的虚假服务端ip为：github.com
        我设置它的虚假服务端管理端口为：1111
        我设置它的虚假服务端用户端口为：2222

        命令为 (在Linux终端执行):
            v_cli/v_cli 127.0.0.1 1234 github.com 1111 2222

按照上面的设置，全地球任何一个能访问github.com的人，只需要访问github.com的1234端口，即可访问到我内网192.168.1.2机器里1234端口的服务。

上面的例子里，如果我内网机器比较富裕，我有两台内网机器（假设另一台内网机器ip为192.168.1.3），那我可以这样玩：

    在域名为github.com的机器里部署虚假服务端：
        我设置它的用户连接端口为：1234
        我设置它的虚假用户管理端口为：1111
        我设置它的虚假用户端口为：2222

        命令为 (在Linux终端执行)：
            v_serv/v_serv 1234 1111 2222
    
    在ip为192.168.1.3的机器里部署虚假用户：
        我设置它的服务端ip为：192.168.1.2
        我设置它的服务端端口为：1234
        我设置它的虚假服务端ip为：github.com
        我设置它的虚假服务端管理端口为：1111
        我设置它的虚假服务端用户端口为：2222

        命令为 (在Linux终端执行):
            v_cli/v_cli 192.168.1.2 1234 github.com 1111 2222

我这个改动，对用户访问是没有任何影响的，但是对某些情况特别有用。就是当我内网机器是无法访问互联网的这种情况：

    192.168.1.2 -- 无法访问互联网

    192.168.1.3 -- 可以访问互联网，且可以访问192.168.1.2

这种情况下，由于192.168.1.2无法访问互联网，所以把虚假用户部署在192.168.1.2上毫无作用。但是192.168.1.3就有意思了，它即可以访问互联网，又可以访问192.168.1.2，这样就可以让192.168.1.3当这个工具人。

不要问为什么不直接把服务部署在192.168.1.3，问就是192.168.1.2机器的性能比较高，存储比较大，更适合做服务器。

不要问为什么192.168.1.2为什么无法访问互联网，问就是《安全要求》。

如果我不想用户访问端口和真正的服务端开放的端口一样，那我可以把“用户连接端口”和“服务端端口”设置成不一样的。比如：

    在域名为github.com的机器里部署虚假服务端：
        我设置它的用户连接端口为：4321
        我设置它的虚假用户管理端口为：1111
        我设置它的虚假用户端口为：2222

        命令为 (在Linux终端执行)：
            v_serv/v_serv 4321 1111 2222
    
    在ip为192.168.1.3的机器里部署虚假用户：
        我设置它的服务端ip为：192.168.1.2
        我设置它的服务端端口为：1234
        我设置它的虚假服务端ip为：github.com
        我设置它的虚假服务端管理端口为：1111
        我设置它的虚假服务端用户端口为：2222

        命令为 (在Linux终端执行):
            v_cli/v_cli 192.168.1.2 1234 github.com 1111 2222

这样用户就可以通过github.com的4321端口来访问192.168.1.2的1234端口了。

# 原理

    就是先这样，然后再这样，然后再这样，最后再这样。听懂了吧？

    不是，你怎么听不懂捏？你得先这样！然后再这样！然后再这样，最后你再这样！听懂了没有？

    不是，你怎么听不明白呢？你得先这样，然后再......哎，你听懂了是吧？太好了你总算是听懂了。

                                                                        ————你的甲方

好了，玩笑说到这里，这个工具的原理是这样的：

    1. [虚假用户]连接到[虚假服务端]的虚假用户管理端口
                    [虚假服务端] <---- [虚假用户]

    2. [虚假服务端]创建一个[监听用户]的进程，监听用户连接端口
                    [虚假服务端] ----- [虚假用户]
                         |
                     [监听用户]
    
    3. 当有用户连接的时候，[监听用户]进程执行监听虚假用户
                    [虚假服务端] ----- [虚假用户]
                         |
    [用户] ------> [监听虚假用户]

        与此同时，虚假服务端给虚假用户发送信息
                    [虚假服务端] ----> [虚假用户]
                         |
    [用户] ------> [监听虚假用户]

    4. [虚假用户]创建一个到[监听虚假用户]的连接
                    [虚假服务端] ----- [虚假用户]
                         |                |
    [用户] ------> [监听虚假用户] <---- [专用连接]

    5. [专用连接]进程执行连接服务端
                    [虚假服务端] ----> [虚假用户]
                         |                |
    [用户] ------> [监听虚假用户] ---- [连接服务端] ----> [服务端]

    6. 此时，一个用户到服务端的连接已经打通。回到第2步（[虚假服务端]再创建一个[监听用户]进程，等待下一个用户连接）

这个工具的原理就如上所说，至于实现方面：

首先要关注的是`v_serv/v_serv_mgr.sh`，这个是虚假服务端的入口（v_serv/v_serv只是一个界面和参数校验而已）。

这里v_serv_mgr.sh一开始就是启动了一个nc，这个nc在等待虚假用户的连接。

这个时候就要关注`v_cli/v_cli_mgr.sh`了，v_cli_mgr.sh会连接到v_serv_mgr.sh启动的nc。

v_cli_mgr.sh创建nc连接到v_serv_mgr.sh的nc后，v_serv_mgr.sh的nc会执行v_serv_listen_mgr.sh，这时就会循环等待用户连接，通过ss查看用户连接端口的状态来判断用户是否连接进来了。

当用户连接进来后就会给v_cli_mgr.sh的nc执行的脚本（也就是v_cli_connect_mgr.sh）里发送“user in”信息。

当v_cli_connect_mgr.sh收到“user in”信息后就会创建连接到虚假服务端的nc，这个nc当连接到虚假服务端后，就会执行一个nc连接到服务端，这样就打通了两边的连接了。
